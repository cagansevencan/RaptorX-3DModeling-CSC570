#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
#include <map>
#include <algorithm>
#include <getopt.h>
#include <dirent.h>
#include <unistd.h>
#include <stdio.h>
using namespace std;


//------- AA coding -------//
const int AA2SUB[26]={0,20,1,2,3,4,5,6,7,20,8,9,10,11,20,12,13,14,15,16,20,17,18,20,19,20};
string AA3Coding[26]={"ALA","XXX","CYS","ASP","GLU","PHE","GLY","HIS","ILE","XXX","LYS","LEU","MET","ASN","XXX","PRO","GLN","ARG","SER","THR","XXX","VAL","TRP","XXX","TYR","XXX"};


//-------- utility ------//
void getBaseName(string &in,string &out,char slash,char dot)
{
	int i,j;
	int len=(int)in.length();
	for(i=len-1;i>=0;i--)
	{
		if(in[i]==slash)break;
	}
	i++;
	for(j=len-1;j>=0;j--)
	{
		if(in[j]==dot)break;
	}
	if(j==-1)j=len;
	out=in.substr(i,j-i);
}
void getRootName(string &in,string &out,char slash)
{
	int i;
	int len=(int)in.length();
	for(i=len-1;i>=0;i--)
	{
		if(in[i]==slash)break;
	}
	if(i<=0)out=".";
	else out=in.substr(0,i);
}

//============ read in TGT file ==============//
int Read_TGT_SEQRES(string &in_file,string &seqres)
{
	ifstream fin;
	string buf,temp;
	//read
	fin.open(in_file.c_str(), ios::in);
	if(fin.fail()!=0)
	{
		fprintf(stderr,"invalid TGT file: %s \n",in_file.c_str());
		exit(-1);
	}
	//process
	int i;
	seqres="";
	for(i=0;i<3;i++)
	{
		if(!getline(fin,buf,'\n'))
		{
			fprintf(stderr,"bad format of TGT file: %s \n",in_file.c_str());
			exit(-1);
		}
	}
	//[map1]
	if(!getline(fin,buf,'\n'))
	{
		fprintf(stderr,"bad format of TGT file: %s \n",in_file.c_str());
		exit(-1);
	}
	istringstream www1(buf);
	for(i=0;i<3;i++)
	{
		if(! (www1>>temp))
		{
			fprintf(stderr,"bad format of TGT file: %s \n",in_file.c_str());
			exit(-1);
		}
	}
	seqres=temp;
	return (int)seqres.length();
}

//===================== NEFF process ====================//
//[0]record the NEFF for each column
void Tpl_File_All_Neff(string &infile,vector <int> &neff_set,int length)
{
	ifstream fin;
	string buf,temp;
	fin.open(infile.c_str(), ios::in);
	if(fin.fail()!=0)
	{
		printf("file %s not found !!\n",infile.c_str());
		exit(-1);
	}
	//skip
	int i,j;
	int len;
	for(;;)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("%s format bad!\n",infile.c_str());
			exit(-1);
		}
		len=(int)buf.length();
		if(len<30)continue;
		temp=buf.substr(0,30);
		if(temp=="//////////// Original HHM file")break;
	}
	for(i=0;i<5;i++)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("%s format bad!\n",infile.c_str());
			exit(-1);
		}
	}
	//process
	int neff;
	neff_set.clear();
	for(i=0;i<length;i++)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("%s format bad!\n",infile.c_str());
			exit(-1);
		}
		if(!getline(fin,buf,'\n'))
		{
			printf("%s format bad!\n",infile.c_str());
			exit(-1);
		}
		istringstream www(buf);
		for(j=0;j<8;j++)
		{
			if(! (www>>temp))
			{
				printf("file format bad! %s \n",infile.c_str());
				exit(-1);
			}
		}
		neff=atoi(temp.c_str());
		neff_set.push_back(neff);
		if(!getline(fin,buf,'\n'))
		{
			printf("%s format bad!\n",infile.c_str());
			exit(-1);
		}
	}
	fin.close();
	fin.clear();
}
double Tpl_File_Calc_Neff_II(vector <int> &neff_set,vector <int> &mapping,int length)
{
	int i;
	int tot_neff=0;
	int totcount=0;
	for(i=0;i<length;i++)
	{
		if(mapping[i]==1)
		{
			tot_neff+=neff_set[i];
			totcount++;
		}
	}
	if(totcount==0)return tot_neff;
	else return 1.0*tot_neff/totcount;
}

//===================== output TGT file =================//
/*
//////////// Original SS2 file (generated by PSIPRED)
//////////// 2011-10-29  0:0:30
   1 E C   0.999  0.000  0.001
   2 N C   0.813  0.002  0.243
   3 I E   0.040  0.000  0.959
   4 E E   0.010  0.000  0.992
.....
*/

/*
SS3:   H     E     L  | SS8:   H     G     I     E     B     T     S     L  | ACC:  Bury   Medium  Exposed
   0.000 0.000 1.000       0.000 0.000 0.000 0.000 0.000 0.000 0.000 1.000      0.000520 0.021237 0.978243      E 1
   0.000 0.254 0.745       0.000 0.000 0.000 0.379 0.004 0.000 0.000 0.617      0.012561 0.218901 0.768538      N 2
   0.004 0.926 0.072       0.000 0.000 0.000 0.946 0.002 0.000 0.008 0.045      0.481319 0.435151 0.083530      I 3
   0.001 0.980 0.018       0.000 0.000 0.000 0.992 0.000 0.000 0.000 0.008      0.068506 0.447094 0.484400      E 4
.....
*/
void Tpl_File_Cut_Output_Single_II(ifstream &fin,vector <int> &mapping,int length,FILE *fp,int lines=1)
{
	int i,j;
	int len;
	string buf,temp;
	//process
	for(i=0;i<length;i++)
	{
		for(j=0;j<lines;j++)
		{
			if(!getline(fin,buf,'\n'))
			{
				printf("file format bad!\n");
				exit(-1);
			}
			len=(int)buf.length();
			if(len>=12)
			{
				temp=buf.substr(0,12);
				if(temp=="////////////")
				{
					printf("file format bad!\n");
					exit(-1);
				}
			}
			if(mapping[i]==1)fprintf(fp,"%s\n",buf.c_str());
		}
	}
}
//----- get mapping ------//
/*
from ->
   0.000 0.000 1.000       0.000 0.000 0.000 0.000 0.000 0.000 0.000 1.000      0.000520 0.021237 0.978243      E 1
to   ->
   1 E C   0.999  0.000  0.001
*/
void Get_SS2_Mapping_String(string &in,string &out)
{
	vector <string> rec;
	istringstream www(in);
	for(int i=0;i<16;i++)
	{
		string temp;
		if(! (www>>temp) )
		{
			printf("file format bad!\n");
			exit(-1);
		}
		rec.push_back(temp);
	}
	//output
	char command[30000];
	int pos=atoi(rec[15].c_str());
	char ami=rec[14][0];
	double h_prob=atof(rec[0].c_str());
	double e_prob=atof(rec[1].c_str());
	double c_prob=atof(rec[2].c_str());
	char sse='C';
	if(h_prob>e_prob && h_prob>c_prob)sse='H';
	if(e_prob>h_prob && e_prob>c_prob)sse='E';
	sprintf(command,"%4d %c %c %7.3f%7.3f%7.3f\n",pos,ami,sse,c_prob,h_prob,e_prob);
	out=command;
}
//----- real process -----//
void TGT_File_Cut_Output_II(ifstream &fin,vector <int> &mapping,int length,FILE *fp)
{
	string buf,temp;
	string header,head;
	string time_line;
	int i,j;
	int len;

	//[2-2] output psi_blast_1
	//skip
	for(;;)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("file format bad!\n");
			exit(-1);
		}
		len=(int)buf.length();
		if(len<30)continue;
		temp=buf.substr(0,30);
		if(temp=="//////////// Original PSM file")break;
	}
	head=buf;
	if(!getline(fin,header,'\n'))
	{
		printf("file format bad!\n");
		exit(-1);
	}
	time_line=header;
	fprintf(fp,"%s\n",head.c_str());
	fprintf(fp,"%s\n",header.c_str());
	Tpl_File_Cut_Output_Single_II(fin,mapping,length,fp);
	fprintf(fp,"\n\n\n");

	//[2-3] output psi_blast_2
	//skip
	for(;;)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("file format bad!\n");
			exit(-1);
		}
		len=(int)buf.length();
		if(len<30)continue;
		temp=buf.substr(0,30);
		if(temp=="//////////// Original PSP file")break;
	}
	head=buf;
	if(!getline(fin,header,'\n'))
	{
		printf("file format bad!\n");
		exit(-1);
	}
	fprintf(fp,"%s\n",head.c_str());
	fprintf(fp,"%s\n",header.c_str());
	Tpl_File_Cut_Output_Single_II(fin,mapping,length,fp);
	fprintf(fp,"\n\n\n");

	//[2-6] output HHpred
	//skip
	for(;;)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("file format bad!\n");
			exit(-1);
		}
		len=(int)buf.length();
		if(len<30)continue;
		temp=buf.substr(0,30);
		if(temp=="//////////// Original HHM file")break;
	}
	head=buf;
	if(!getline(fin,header,'\n'))
	{
		printf("file format bad!\n");
		exit(-1);
	}
	fprintf(fp,"%s\n",head.c_str());
	fprintf(fp,"%s\n",header.c_str());
	for(i=0;i<4;i++)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("file format bad!\n");
			exit(-1);
		}
		fprintf(fp,"%s\n",buf.c_str());
	}
	//output HMM body
	Tpl_File_Cut_Output_Single_II(fin,mapping,length,fp,3);
	fprintf(fp,"\n\n\n");


	//[2-7] output structure info
	//skip
	for(;;)
	{
		if(!getline(fin,buf,'\n'))
		{
			printf("file format bad!\n");
			exit(-1);
		}
		len=(int)buf.length();
		if(len<30)continue;
		temp=buf.substr(0,30);
		if(temp=="//////////// Original SS3+SS8+")break;
	}
	head=buf;
	if(!getline(fin,header,'\n'))
	{
		printf("file format bad!\n");
		exit(-1);
	}
	if(!getline(fin,temp,'\n'))
	{
		printf("file format bad!\n");
		exit(-1);
	}
	string ss2_header="//////////// Original SS2 file (generated by PSIPRED)";
	fprintf(fp,"%s\n",ss2_header.c_str());
	fprintf(fp,"%s\n",time_line.c_str());
	//---- output TGT derived SS2 info -----//
	int lines=1;
	for(i=0;i<length;i++)
	{
		for(j=0;j<lines;j++)
		{
			if(!getline(fin,buf,'\n'))
			{
				printf("file format bad!\n");
				exit(-1);
			}
			len=(int)buf.length();
			if(len>=12)
			{
				temp=buf.substr(0,12);
				if(temp=="////////////")
				{
					printf("file format bad!\n");
					exit(-1);
				}
			}
			if(mapping[i]==1)
			{
				string sse_str;
				Get_SS2_Mapping_String(buf,sse_str);
				fprintf(fp,"%s",sse_str.c_str());
			}
		}
	}
}


//============ read in FEAT file =============//
//-> file format
/*
  Num Res  Missing   SSE    CLE   ACC   pACC  CNa CNb   Xca       Yca       Zca       Xcb       Ycb       Zcb
   1   E      0       L      R     2     87   2   1     19.375     4.600    31.639    17.889     4.542    31.872
   2   N      0       E      R     2     48   4   3     20.501     7.608    33.670    21.326     8.630    32.887
   3   I      0       E      E     1     18   3   5     18.924     9.098    36.780    18.496     8.208    37.931
   4   E      0       E      E     2     53   3   2     19.887    12.671    37.725    19.630    13.781    36.734
   5   V      0       E      E     0      0   6   9     20.160    13.626    41.423    20.814    12.502    42.276
*/
int FEAT_File_Input(string &in_file,vector <string> &out,string &ami_)
{
	ifstream fin;
	string buf,temp;
	fin.open(in_file.c_str(), ios::in);
	if(fin.fail()!=0)
	{
		fprintf(stderr,"%s not found!\n",in_file.c_str());
		exit(-1);
	}
	//skip first
	if(!getline(fin,buf,'\n'))
	{
		fprintf(stderr,"%s format error!\n",in_file.c_str());
		exit(-1);
	}
	//load
	out.clear();
	ami_="";
	int count=0;
	for(;;)
	{
		if(!getline(fin,buf,'\n'))break;
		istringstream www(buf);
		www>>temp>>temp;
		out.push_back(buf);
		ami_+=temp;
		count++;
	}
	return count;
}


//============ read in SEQRES file ===========//
//-> file format
/*
>test
ASSDFGHJIWOWEPELR
*/
//-- Getline_Ending ---//
void getline_end(string &input,char kill)
{
	int len=(int)input.length();
	if(input[len-1]==kill)input=input.substr(0,len-1);
}
//---- kill invalid character ----//
void Kill_Invalid(string &in,string &out)
{
	int i;
	int len=(int)in.length();
	out="";
	for(i=0;i<len;i++)
	{
		if(in[i]!=' ' && in[i]!='-' )out=out+in[i];
	}
}
//---- seqres file input ----//
int SEQRES_File_Input(string &in_file,string &seqres)
{
	ifstream fin;
	string buf,temp;
	fin.open(in_file.c_str(), ios::in);
	if(fin.fail()!=0)
	{
		fprintf(stderr,"%s not found!\n",in_file.c_str());
		exit(-1);
	}
	string seqres_="";
	for(;;)
	{
		if(!getline(fin,buf,'\n'))break;
		getline_end(buf,0x0D);
		if(buf[0]!='>') seqres_+=buf;
	}
	Kill_Invalid(seqres_,seqres);
	return (int)seqres.length();
}

//========== read in PDB file ========//
/*
ATOM      7  CD  GLU A   1      15.753   4.149  33.089  1.00 86.91      A    C
ATOM      8  OE1 GLU A   1      15.215   3.536  32.181  1.00 86.91      A    O
ATOM      9  OE2 GLU A   1      15.183   4.847  34.040  1.00 84.58      A    O
ATOM     10  N   ASN A   2      19.889   6.684  32.725  1.00 19.40      A    N
....
*/
char WWW_Three2One_III(const char *input)
{
	int i;
	int len;
	int result;
	//encoding
	len=(int)strlen(input);
	if(len!=3)return 'X';
	result=0;
	for(i=0;i<len;i++)result+=(input[i]-'A')*(int)pow(1.0*26,1.0*i);
	//switch
	switch(result)
	{
		case 286:return 'A';
		case 4498:return 'R';
		case 9256:return 'N';
		case 10608:return 'D';
		case 12794:return 'C';
		case 9080:return 'Q';
		case 13812:return 'E';
		case 16516:return 'G';
		case 12383:return 'H';
		case 2998:return 'I';
		case 13635:return 'L';
		case 12803:return 'K';
		case 12960:return 'M';
		case 2901:return 'F';
		case 9921:return 'P';
		case 11614:return 'S';
		case 11693:return 'T';
		case 10601:return 'W';
		case 12135:return 'Y';
		case 7457:return 'V';
		default:return 'X';
	}
}
int PDB_File_Input(string &in_file,string &ami_,vector <int> &int_,string &ins_)
{
	map<string, int>::iterator iter;
	map<string, int > mapping;
	ifstream fin;
	string buf,temp;
	fin.open(in_file.c_str(), ios::in);
	if(fin.fail()!=0)
	{
		fprintf(stderr,"%s not found!\n",in_file.c_str());
		exit(-1);
	}
	//record
	int count=0;
	ami_="";
	int_.clear();
	ins_="";
	for(;;)
	{
		if(!getline(fin,buf,'\n'))break;
		int len=(int)buf.length();
		if(len<3)continue;
		//check TER
		temp=buf.substr(0,3);
		if(temp=="TER"||temp=="END")break;
		//check ATOM
		if(len<4)continue;
		temp=buf.substr(0,4);
		if(temp!="ATOM" && temp!="HETA")continue;
		//check CA
		temp=buf.substr(13,2);
		if(temp!="CA")continue;
		//record name
		string name=buf.substr(21,6);
		iter = mapping.find(name);
		if(iter != mapping.end())continue;
		count++;
		mapping.insert(map < string, int >::value_type(name, count));
		//ami_
		temp=buf.substr(17,3);
		char c=WWW_Three2One_III(temp.c_str());
		ami_=ami_+c;
		//int_
		temp=buf.substr(22,4);
		int pos=atoi(temp.c_str());
		int_.push_back(pos);
		//ins_
		char s=buf[26];
		ins_=ins_+s;
	}
	return count;
}


//================== dynamic programming =================//
int WWW_Advance_Align_Dyna_Prog_Double(int n1,int n2,const vector<double> &score,
								   double GAP_OPEN1,double GAP_EXT1,double GAP_OPEN2,double GAP_EXT2,
								   double GAP_HEAD1,double GAP_TAIL1,double GAP_HEAD2,double GAP_TAIL2,
								   vector<pair<int,int> > & alignment,double &ali_sco)
{
	int i,j;
	//input
	int m = n1 + 1;  // +1 to account for the extra row,col in
	int n = n2 + 1;  // the DP matrices corresponding to gaps
	int DP_maximal=n;
	int IN_maximal=n2;
	//const value
	const int _H_  = 0;
	const int _S_  = 1;
	const int _V_  = 2;

	//create D and M
	vector <int> D[3];      // the path (directions) matrix
	vector <double> M[3];   // the current scores (values) matrix
	//resize(m,n)
	for (i = 0; i < 3; ++i) 
	{
		D[i].resize(m*n);
		M[i].resize(m*n);
	}
	//init()
	double MIN=-1000000;
	D[_S_][0*DP_maximal+ 0] = -1;
	D[_H_][0*DP_maximal+ 0] = -1;
	D[_V_][0*DP_maximal+ 0] = -1;
	M[_S_][0*DP_maximal+ 0] = 0;
	M[_H_][0*DP_maximal+ 0] = MIN;
	M[_V_][0*DP_maximal+ 0] = MIN;
	for (i = 1; i < m; i++) 
	{
		D[_S_][i*DP_maximal+ 0] = _V_;
		D[_H_][i*DP_maximal+ 0] = _V_;
		D[_V_][i*DP_maximal+ 0] = _V_;
		M[_S_][i*DP_maximal+ 0] = MIN;
		M[_H_][i*DP_maximal+ 0] = MIN;
		M[_V_][i*DP_maximal+ 0] = i*GAP_HEAD1; //-(Params::GAP_OPEN + (i-1)*Params::GAP_EXT);
	}
	for (j = 1; j < n; j++) 
	{
		D[_S_][0*DP_maximal+ j] = _H_;
		D[_H_][0*DP_maximal+ j] = _H_;
		D[_V_][0*DP_maximal+ j] = _H_;
		M[_S_][0*DP_maximal+ j] = MIN;
		M[_H_][0*DP_maximal+ j] = j*GAP_HEAD2; //-(Params::GAP_OPEN + (j-1)*Params::GAP_EXT);
		M[_V_][0*DP_maximal+ j] = MIN;
	}
	//fill(firstSeq, secondSeq, distFunc);
	double gap_open;
	double gap_ext;
	double v1,v2,v3;
	double dist;
	for (i = 1; i < m; i++) 
	{
		for (j = 1; j < n; j++) 
		{
			//condition upper
			if(j==n-1)
			{
				gap_open=GAP_TAIL1;
				gap_ext=GAP_TAIL1;
			}
			else
			{
				gap_open=GAP_OPEN1;
				gap_ext=GAP_EXT1;
			}
			v1 = M[_V_][(i-1)*DP_maximal+ j] + gap_ext;
			v2 = M[_S_][(i-1)*DP_maximal+ j] + gap_open;
			v3 = M[_H_][(i-1)*DP_maximal+ j] + gap_open;
			M[_V_][i*DP_maximal+ j] = std::max(v1, std::max(v2, v3));
			if (M[_V_][i*DP_maximal+ j] == v1) D[_V_][i*DP_maximal+ j] = _V_;
			else if(M[_V_][i*DP_maximal+ j] == v2) D[_V_][i*DP_maximal+ j] = _S_;
			else D[_V_][i*DP_maximal+ j] = _H_;
			//condition left
			if(i==m-1)
			{
				gap_open=GAP_TAIL2;
				gap_ext=GAP_TAIL2;
			}
			else
			{
				gap_open=GAP_OPEN2;
				gap_ext=GAP_EXT2;
			}
			v1 = M[_H_][i*DP_maximal+ j-1] + gap_ext;
			v2 = M[_S_][i*DP_maximal+ j-1] + gap_open;
			v3 = M[_V_][i*DP_maximal+ j-1] + gap_open;
			M[_H_][i*DP_maximal+ j] = std::max(v1, std::max(v2, v3));
			if (M[_H_][i*DP_maximal+ j] == v1) D[_H_][i*DP_maximal+ j] = _H_;
			else if(M[_H_][i*DP_maximal+ j] == v2) D[_H_][i*DP_maximal+ j] = _S_;
			else D[_H_][i*DP_maximal+ j] = _V_;
			//condition diag
			dist = score.at((i-1)*IN_maximal+ j-1);  //Params::K - distFunc(firstSeq[i-1], secondSeq[j-1]);
			v1 = M[_V_][(i-1)*DP_maximal+ j-1] + dist;
			v2 = M[_H_][(i-1)*DP_maximal+ j-1] + dist;
			v3 = M[_S_][(i-1)*DP_maximal+ j-1] + dist;
			M[_S_][i*DP_maximal+ j] = std::max(v1, std::max(v2, v3));
			if (M[_S_][i*DP_maximal+ j] == v3) D[_S_][i*DP_maximal+ j] = _S_;
			else if (M[_S_][i*DP_maximal+ j] == v1) D[_S_][i*DP_maximal+ j] = _V_;
			else D[_S_][i*DP_maximal+ j] = _H_;
		}
	}
	//build(ali, firstSeq, secondSeq, distFunc);
	i = m-1;
	j = n-1;
	v1=M[_V_][i*DP_maximal+ j];
	v2=M[_H_][i*DP_maximal+ j];
	v3=M[_S_][i*DP_maximal+ j];
	double maximal = std::max(v1, std::max(v2, v3));
	int k = -1;
	if(v3==maximal)k = _S_;
	else if(v2==maximal)k = _H_;
	else k = _V_;
	//trace_back
	alignment.clear();
	int count = 0;
	int matches = 0;
	int cur_case=k;
	int pre_case;
	for(;;)
	{
		if(i==0||j==0)break;
		pre_case=D[cur_case][i*DP_maximal+ j];
		switch (cur_case)
		{
			case _S_:
				alignment.push_back(pair<int,int>(i,j)); 
				i--;
				j--;
				++matches;
				break;
			case _V_:
				alignment.push_back(pair<int,int>(i,-j)); 
				i--;
				break;
			case _H_:
				alignment.push_back(pair<int,int>(-i,j)); 
				j--;
				break;
			default:
				cout << "ERROR!! -> advance_global: invalid direction D[" << k << "](" << i << ", " << j << ") = " 
				<< D[k][i*DP_maximal+ j] << endl;
				exit(-1);
		}
		cur_case=pre_case;
		count++;
	}
	while (j> 0) alignment.push_back(pair<int,int>(-i,j)),j--;
	while (i> 0) alignment.push_back(pair<int,int>(i,0)), i--;
	reverse(alignment.begin(), alignment.end());
	ali_sco=maximal;
	return matches;
}


//======== SEQRES_PDB_alignment ============//
int analyse_seperate(int i1,char c1,int i2,char c2,int &sep) 
{
	if(c1==' ')
	{
		if(c2==' ')sep=i2-i1;
		else
		{
			if(i1==i2)
			{
				sep=c2-'A';
				return -1;
			}
			else
			{
				sep=0;
				return -1;
			}
		}
	}
	else
	{
		if(c2!=' ')
		{
			if(c1==c2)sep=i2-i1;
			else
			{
				if(i1==i2)sep=abs(c2-c1);
				else
				{
					sep=0;
					return -1;
				}
			}
		}
		else
		{
			sep=0;
			return -1;
		}
	}
	if(sep<0)return -1;
	if(i1*i2<0)
	{
		sep--;
		return 2;  // represent:"0"	
	}
	else return 1;  // normal_return
}
int process_oriami_record(string &seqres,string &ami_,vector <int> &int_,string &ins_,string &tag_,
	vector<pair<int,int> > &alignment, vector <int> &wali1, vector <int> &wali2)
{
	string out;
	string out1;
	int i,j;
	int head=0;
	int len;
	int totnum;
	int ii,jj;
	int seperate;
	int ret_val;
	int rec_num;
	int n1,n2;

	//--[0]check
	len=(int)seqres.length();
	totnum=(int)ami_.length();

	//--[1]dynamic_programming	
	n1=len;    //SEQRES
	n2=totnum; //ATOM
	vector <double> score;
	score.resize(len*totnum);
	for(i=0;i<n1;i++)
	{
		for(j=0;j<n2;j++)
		{
			if(seqres[i]==ami_[j+head])score.at(i*n2+j)=10;
			else
			{
				if(seqres[i]=='X'||seqres[i]=='Z'||seqres[i]=='.')score.at(i*n2+j)=0;
				else if(ami_[j+head]=='X'||ami_[j+head]=='Z'||ami_[j+head]=='.')score.at(i*n2+j)=0;
				else score.at(i*n2+j)=-15;
			}
		}
	}
	double sco;
	int matchs;
	matchs=WWW_Advance_Align_Dyna_Prog_Double(n1,n2,score,-11,-1,-110,-10,-22,-22,-110,-110,
		alignment,sco);
	int lcmp=(int)alignment.size();

	//--Output_DP_Result
	//init
	wali1.resize(n1);
	wali2.resize(n2);
	for(j=0;j<n1;j++)wali1[j]=-1;
	for(j=0;j<n2;j++)wali2[j]=-1;

	//record_neo
	i=0;
	ii=0;
	int first,second; //first SEQUES, second ATOM
	int IsInsert=1;
	for(j=0;j<lcmp;j++)
	{
		first=alignment.at(j).first;
		second=alignment.at(j).second;
		if(first<=0)
		{
			if(second>0)
			{
				IsInsert=-1;
				tag_[i+head]='i';
				i++;
			}
		}
		else
		{
			if(second>0)
			{
				wali1.at(ii)=i;  //seqres_ami
				wali2.at(i)=ii;  //atom_ami
				if(seqres[ii]!=ami_[i+head])tag_[i+head]='/';
				i++;
			}
			ii++;
		}
	}
	//bad process
	if(IsInsert==-1)return IsInsert;
	if(matchs<2)return -1;

	//head_tail_tag	
	ii=wali2.at(totnum-1);
	if(ii!=-1)for(i=ii+1;i<len;i++)wali1.at(i)=-2; //tail_tag
	ii=wali2.at(0);
	if(ii!=-1)for(i=0;i<ii;i++)wali1.at(i)=-2; //head_tag

	//analyse_main_backword
	rec_num=0;
	for(i=totnum-1;i>=1;i--)
	{
		if(tag_[i+head]=='i')continue; //__Found_Insert__//__080326__//
		ret_val=analyse_seperate(int_[i-1+head],ins_[i-1+head],int_[i+head],ins_[i+head],seperate);
		ii=wali2.at(i)-seperate; //expected_position
		jj=wali2.at(i-1);        //current_position
		if(ii!=jj && ret_val!=-1 && ii>=0 && ii<len) //error
		{
			if(rec_num>=8)tag_[i+head]*=-1;  //solid!!
			rec_num=0;
			for(j=0;j<ret_val;j++)
			{
				if(ii-j<0)break;
				if(wali1.at(ii-j)==-1)
				{
					if(ami_[i-1+head]==seqres[ii-j])
					{
						if(tag_[i-1+head]=='/')tag_[i-1+head]=' ';
					}
					else if(tag_[i-1+head]!='/')continue;
					if(jj>=0 && jj<n1)wali1.at(jj)=-1;
					wali1.at(ii-j)=i-1;
					wali2.at(i-1)=ii-j;				
					if(seperate==1)tag_[i-1+head]*=-1;  //solid!!
					break;
				}
			}
		}
		else rec_num++;
	}

	//analyse_main_forward
	for(i=0;i<totnum-1;i++)
	{
		if(tag_[i+head]=='i')continue; //__Found_Insert__//__080326__//
		ret_val=analyse_seperate(int_[i+head],ins_[i+head],int_[i+1+head],ins_[i+1+head],seperate);
		ii=wali2.at(i)+seperate; //expected_position
		jj=wali2.at(i+1);        //current_position
		if(ii!=jj && ret_val!=-1 && ii>=0 && ii<len) //error
		{
			if(seperate!=1 && tag_[i+1+head]<0)continue;
			for(j=0;j<ret_val;j++)
			{
				if(ii+j>=len)break;
				if(wali1.at(ii+j)==-1)
				{
					if(ami_[i+1+head]==seqres[ii+j])
					{
						if(tag_[i+1+head]=='/')tag_[i+1+head]=' ';
					}
					else if(tag_[i+1+head]!='/')continue;
					if(jj>=0 && jj<n1)wali1.at(jj)=-1;
					wali1.at(ii+j)=i+1;
					wali2.at(i+1)=ii+j;
					break;
				}
			}
		}
	}

	//[final correction]
	int cur;
	//head_correct
	cur=0;
	ii=wali2.at(cur);     //current
	jj=wali2.at(cur+1)-1; //mapping
	if(ii!=jj && jj>=0 && jj<len)
	{
		if(wali1.at(jj)==-1)
		{
			if(ami_[cur+head]==seqres[jj])
			{
				if(tag_[cur+head]=='/')tag_[cur+head]=' ';
				wali1.at(ii)=-1;
				wali1.at(jj)=cur;
				wali2.at(cur)=jj;
			}
		}
	}
	//tail_correct
	cur=n2-1;
	ii=wali2.at(cur);     //current
	jj=wali2.at(cur-1)+1; //mapping
	if(ii!=jj && jj>=0 && jj<len)
	{
		if(wali1.at(jj)==-1)
		{
			if(ami_[cur+head]==seqres[jj])
			{
				if(tag_[cur+head]=='/')tag_[cur+head]=' ';
				wali1.at(ii)=-1;
				wali1.at(jj)=cur;
				wali2.at(cur)=jj;
			}
		}
	}

	//return
	return 1;
}

//============ SEQRES_ATOM Mapping =============//
int SEQRES_ATOM_Mapping(string &seqresfile,string &pdbfile,
	string &map1_str,string &map2_str)
{
	//load_seqres
	string seqres;
	int seqres_len=SEQRES_File_Input(seqresfile,seqres);
	if(seqres_len<0)
	{
		fprintf(stderr,"SEQRES file error! [%s]\n",seqresfile.c_str());
		exit(-1);
	}

	//load pdb
	string ami_;
	vector <int> int_;
	string ins_;
	int pdb_len=PDB_File_Input(pdbfile,ami_,int_,ins_);
	if(pdb_len<0)
	{
		fprintf(stderr,"PDB file error! [%s]\n",pdbfile.c_str());
		exit(-1);
	}
	string tag_="";
	for(int k=0;k<pdb_len;k++)tag_.push_back(' ');

	//alignment
	vector<pair<int,int> > alignment;
	vector <int> wali1;
	vector <int> wali2;
	int IsInsert=process_oriami_record(seqres,ami_,int_,ins_,tag_,
		alignment,wali1,wali2);

	//output
	int i,j;
	int ii;
	int first,second; //first SEQRES, second ATOM
	int lcmp=(int)alignment.size();
	//-> map1_str
	map1_str="";
	for(j=0;j<lcmp;j++)
	{
		first=alignment.at(j).first;
		if(first<=0)continue;
		ii=first-1;
		map1_str.push_back(seqres[ii]);
	}
	//-> map2_str
	map2_str="";
	for(j=0;j<lcmp;j++)
	{
		first=alignment.at(j).first;
		second=alignment.at(j).second;
		if(first<=0)continue;
		ii=first-1;
		if(wali1.at(ii)<=-1)
		{
			map2_str.push_back('-');
		}
		else
		{
			i=wali1.at(ii);
			map2_str.push_back(ami_[i]);
		}
	}

	//return
	return IsInsert;
}




//---- readme ----//
void Usage(char *arg) 
{
	printf("Version: 1.01 \n");
	printf("Usage: %s -i pdb_file -I tgt_file [ -h chainID ] [ -o tpl_file] [-t tmp] [-H home] [-k] \n",arg);
	printf("       default output name is xxxxY where xxxx is the pdb_file name,and Y is the chainID.\n");
	printf("       default chainID is A. \n");
	printf("       -------------------------------------------- \n");
	printf("       default do not remove non-standard residues, \n");
	printf("       if set -k, then all non-standard residues will be removed. \n");
}
//---- parameter editor ----//
static option long_options[] =
{
	{"input",   required_argument, NULL, 'i'},
	{"Input",   required_argument, NULL, 'I'},
	{"chain",   no_argument,       NULL, 'h'},
	{"output",  no_argument,       NULL, 'o'},
	{"tmpout",  no_argument,       NULL, 't'},
	{"home",    no_argument,       NULL, 'H'},
	{"killbad", no_argument,       NULL, 'k'},
	{0, 0, 0, 0}
};

//------------ main -----------//
int main(int argc, char** argv)
{

	if(argc<2)
	{
		Usage(argv[0]);
		exit(-1);
	}
	string pdbfile="";
	string tgtfile="";
	string pdbID;
	string chainID="A";
	string outnam="";
	string tmpout="";
	string home="";
	int killbad=0;

	//extern int optind;
	char c = 0;
	int option_index=0;
	extern char* optarg;
	while ((c = getopt_long(argc, argv, "i:I:h:o:t:H:k",long_options,&option_index)) != EOF) 
	{
		switch (c) 
		{
			case 'i':
				pdbfile = optarg;
				break;
			case 'I':
				tgtfile = optarg;
				break;
			case 'h':
				chainID = optarg;
				break;
			case 'o':
				outnam = optarg;
				break;
			case 't':
				tmpout = optarg;
				break;
			case 'H':
				home = optarg;
				break;
			case 'k':
				killbad = 1;
				break;
			default:
				Usage(argv[0]);
				exit(-1);
		}
	}
	//check input file
	int retv;
	if(pdbfile=="")
	{
		Usage(argv[0]);
		exit(-1);
	}
	if(tgtfile=="")
	{
		Usage(argv[0]);
		exit(-1);
	}
	if(chainID.length()!=1)
	{
		fprintf(stderr,"WARNING: chainID should be only one letter. Using %c instead. \n",chainID[0]);
		chainID=chainID[0];
	}
	getBaseName(pdbfile,pdbID,'/','.');
	string fileout="";
	getBaseName(outnam,fileout,'/','.');
	string templateName;
	if(fileout=="")templateName = pdbID + chainID;
	else templateName = fileout;
	if(outnam=="")outnam=templateName+".tpl";

	//home and tmp dir
	char *wd(getcwd(NULL,0));
	string cwd(wd);
	free(wd);
	if(tmpout=="")tmpout=cwd+"/tmp_"+templateName+"/";
	string mkdir_cmd = "mkdir -p "+tmpout;
	system(mkdir_cmd.c_str());
	if(home=="")home=cwd+"/";

	//----- init sequence ------//
	string sequence = "";
	int fullLen=0;
	const int BufLen = 100000;
	char buf[BufLen];


//---------------- read SEQRES from PDB -------------// part_I
int start=0;
{
	ifstream pdbfile_in(pdbfile.c_str());
	string temp_pdbfile = tmpout + "/" + templateName + ".pdb_pre";
	ofstream temp_pdb_out(temp_pdbfile.c_str());
	if(pdbfile_in.fail()!=0)
	{
		fprintf(stderr,"input pdb file %s error !!!\n",pdbfile.c_str());
		exit(-1);
	}
	int residue_index = -1000000;
	
	//---- read original PDB ----//
	while(pdbfile_in.getline(buf,BufLen))
	{
		// break condition
		if(start == 1 &&strncmp(buf,"TER",3) == 0)
			break;
		if(start == 1 &&strncmp(buf,"END",3) == 0)
			break;

		// save template PDB file
		if((strncmp(buf,"HETATM",6) == 0 || strncmp(buf,"ATOM",4) == 0) && buf[21] == chainID[0])
		{
			//neo_add//__to remove the HOH noise !!//__110720__//
			char _buf[4];
			strncpy(_buf,buf+17,3);
			_buf[3]='\0';
			if(strcmp(_buf,"HOH")==0)continue;
			//modify HETATM
			if(strncmp(buf,"HETATM",6) == 0)
			{
				buf[0]='A',buf[1]='T',buf[2]='O',buf[3]='M',buf[4]=' ',buf[5]=' ';
				buf[17]='M', buf[18]='E', buf[19]='T';
			}
			//exclude BAD residues //__160514__//
			strncpy(_buf,buf+17,3);
			_buf[3]='\0';
			string aa3=_buf;
			int aa1 = -1;
			for(int i=0;i<26;i++)if(aa3 == AA3Coding[i])aa1 = i;
			if(aa1<0) continue;
			if(aa3=="XXX" || aa3=="UNK") continue;
			//write to file
			start = 1;
			temp_pdb_out << buf << endl;
		}
	}
	pdbfile_in.close();
	temp_pdb_out.close();
	fullLen = sequence.size();
}
//----------- check length i ---------//
{
	if(start==0)
	{
		fprintf(stderr,"assigned chainID %s not appear \n",chainID.c_str());
		exit(-1);
	}
}

//---------------- read SEQRES from tgt file -------------// part_I
	//----- first output sequence -------//__110830__//
	fullLen=Read_TGT_SEQRES(tgtfile,sequence);
	int ori_full_len=fullLen;
	if(fullLen==0)
	{
		fprintf(stderr,"tgtfile %s format bad \n",tgtfile.c_str());
		exit(-1);
	}
	string seqres_file = tmpout + "/" + templateName + ".seq";
	if(fullLen!=0)
	{
		ofstream seqfile_out_first(seqres_file.c_str());
		seqfile_out_first << ">" << templateName << endl;
		seqfile_out_first << sequence << endl;
		seqfile_out_first.close();
	}
	//---- run PDB_Tool ------//__110710__//
	string PDB_Tool_CMD= home + "/bin/PDB_Tool -i " + tmpout + "/" + templateName + ".pdb_pre" + " -o " + tmpout + "/" + templateName + ".pdb" + " -R 1 -F 4";
	retv=system(PDB_Tool_CMD.c_str());
	//check generated pdb
	string pdb_file= tmpout + "/" + templateName + ".pdb";
	ifstream fin_pdb(pdb_file.c_str());
	if(!fin_pdb.is_open())
	{
		fprintf(stderr,"processed pdb file %s error !!!\n",pdb_file.c_str());
		exit(-1);
	}
	fin_pdb.close();
	//load feature file
	string feat_file= tmpout + "/" + templateName + ".feature";
	vector <string> pdb_feature;
	string pdb_ami;
	int pdb_len=FEAT_File_Input(feat_file,pdb_feature,pdb_ami);


//--------------- SEQRES <-> ATOM mapping -------------// part_II
	string seqres_str,dssp_str;
	retv=SEQRES_ATOM_Mapping(seqres_file,pdb_file,seqres_str,dssp_str);
	if(retv!=1)
	{
		fprintf(stderr,"WARNING -> tgt_file %s has insertion compared to pdb_file %s \n", tgtfile.c_str(), pdb_file.c_str() );
		fprintf(stderr,"%s\n%s\n",seqres_str.c_str(),dssp_str.c_str());
	}
	//------- checking mapping i ------//__110710__//
	int index = 0;
	vector<int> mapping;
	for(int i=0;i<(int)dssp_str.length();i++)
	{
		if(dssp_str[i]=='-')
		{
			mapping.push_back(-1);
		}
		else
		{
			mapping.push_back(index);
			index++;
		}
	}
	//---- checking mapping ii ----//__110830__//
	{
		int wi;
		int wlen1=(int)sequence.length();
		int wlen2=(int)dssp_str.length();
		if(index!=pdb_len)
		{
			fprintf(stderr," mapping length not equal to pdb length [%d!=%d] !!!\n",index,pdb_len);
			exit(-1);
		}
		if(wlen1!=wlen2)
		{
			fprintf(stderr,"mapping length not equal [%d!=%d] !!!\n",wlen1,wlen2);
			exit(-1);
		}
		if(sequence!=seqres_str)
		{
			fprintf(stderr,"mapping sequence not equal [%s!=%s] !!!\n",sequence.c_str(),seqres_str.c_str());
			exit(-1);
		}
		int wlen=wlen1;
		for(wi=0;wi<wlen;wi++)
		{
			if(dssp_str[wi]=='-')continue;
			if(dssp_str[wi]!=sequence[wi])sequence[wi]=dssp_str[wi];
		}
	}


	//======================= remove non-standard residues ===================//
	vector <int> mapping_ii;
	mapping_ii.resize(fullLen);
	for(int i=0;i<fullLen;i++)mapping_ii[i]=1;
	if(killbad==1)
	{
		//---- get good sequence ---//
		int len=(int)sequence.length();
		string sequence_new="";
		string dssp_new="";
		string dssp_str_new="";
		for(int i=0;i<len;i++)
		{
			char a=dssp_str[i];
			if(a=='-')
			{
				sequence_new+=sequence[i];
				dssp_str_new+=dssp_str[i];
			}
			else
			{
				//check
				int good=1;
				if(a<'A' || a>'Z')good=0;
				else if(AA2SUB[a-'A']==20)good=0;
				else good=1;
				//add
				if(good==1)
				{
					sequence_new+=sequence[i];
					dssp_str_new+=dssp_str[i];
					dssp_new+=dssp_str[i];
				}
				else
				{
					mapping_ii[i]=0;
				}
			}
		}
		//---- create new sequence and pdb -----//
		if(dssp_str_new!=dssp_str)
		{
			//-> regenerate pdb
			{
				//--> output dssp_seq
				ofstream seqfile_out_first(seqres_file.c_str());
				seqfile_out_first << ">" << templateName << endl;
				seqfile_out_first << dssp_new << endl;
				seqfile_out_first.close();
				//--> regenerate pdb
				string PDB_Cut_CMD= home + "/util/PDB_File_Cut " + pdb_file + " " + seqres_file + " "+ pdb_file + "_" ;
				retv=system(PDB_Cut_CMD.c_str());
				string PDB_Tool_CMD2= home + "/bin/PDB_Tool -i " + pdb_file + "_" + " -o "+ pdb_file + " -R 1 -F 4";
				retv=system(PDB_Tool_CMD2.c_str());
				string PDB_RM_CMD= (string)"rm -f " + pdb_file + "_";
				retv=system(PDB_RM_CMD.c_str());
				//--> reload features
				pdb_len=FEAT_File_Input(feat_file,pdb_feature,pdb_ami);
				dssp_str=dssp_str_new;
			}
			//-> regenerate seqres
			{
				ofstream seqfile_out_first(seqres_file.c_str());
				seqfile_out_first << ">" << templateName << endl;
				seqfile_out_first << sequence_new << endl;
				seqfile_out_first.close();
				sequence=sequence_new;
				fullLen=(int)sequence_new.length();
			}
			//-> regenerate mapping
			{
				index = 0;
				mapping.clear();
				for(int i=0;i<(int)dssp_str.length();i++)
				{
					if(dssp_str[i]=='-')
					{
						mapping.push_back(-1);
					}
					else
					{
						mapping.push_back(index);
						index++;
					}
				}
			}
		}
	}


// get current time
	time_t t = time(NULL);
	struct tm tm = *localtime(&t);

// read NEFF
	float NEFF;
	{
		//read_in neff
		vector <int> neff_set;
		Tpl_File_All_Neff(tgtfile,neff_set,ori_full_len);
		double tot_neff=1.0*Tpl_File_Calc_Neff_II(neff_set,mapping_ii,ori_full_len)/1000;
		int tot_neff_int=(int)tot_neff;
		double tot_neff_small=tot_neff-tot_neff_int+0.05;
		int tot_neff_sma=(int)(10.0*tot_neff_small);
		NEFF=tot_neff_int+0.1*tot_neff_sma;
	}

// TPL file
	string out_filename=outnam;
	FILE *fp=fopen(out_filename.c_str(),"wb");
// output all features
	fprintf(fp,"Version 1.1\n");
	fprintf(fp,"Template Name  = %s\n",templateName.c_str());
	fprintf(fp,"Chain ID = %c\n",chainID[0]);
	fprintf(fp,"Length  = %d\n",fullLen);
	fprintf(fp,"SEQRES sequence = %s\n",sequence.c_str());
	fprintf(fp,"DSSP   sequence = %s\n",dssp_str.c_str());
	fprintf(fp,"NEFF = %3.1f\n",NEFF);
	fprintf(fp,"Date = %d-%d-%d %d:%d%d\n",
		tm.tm_year + 1900,tm.tm_mon+1,tm.tm_mday,tm.tm_hour,tm.tm_hour,tm.tm_sec);

//--------------- output structural features --------------//
{
	fprintf(fp,"\n\n");
	fprintf(fp,"//////////// Features \n");
	fprintf(fp,"  Num Res  Missing   SSE    CLE   ACC   pACC  CNa CNb   Xca       Yca       Zca       Xcb       Ycb       Zcb\n");
	int cur_pos=0;
	for(int i=0;i<fullLen;i++)
	{
		char tmp[BufLen];
		sprintf(tmp,"%4d", i+1);
		if(mapping[i]>=0)
		{
			string temp=pdb_feature[cur_pos];
			string tomp=temp.substr(4,temp.length()-4);
			fprintf(fp,"%s%s\n",tmp,tomp.c_str());
			cur_pos++;
		}
		else
		{
			char sse='L';
			char cle='R';
			char acc='2';
			fprintf(fp,"%s   %c      %1d       %c      %c     %c   ",tmp,sequence[i],(mapping[i]<0),sse,cle,acc);
			int pacc=45;
			int can=0;
			int cbn=0;
			sprintf(tmp,"%4d  %2d  %2d", pacc, can, cbn);
			fprintf(fp,"%s   \n",tmp);
		}
	}
	fprintf(fp,"\n\n\n");
}


//---------------- output sequence features ---------------//
	ifstream fin;
	fin.open(tgtfile.c_str(), ios::in);
	TGT_File_Cut_Output_II(fin,mapping_ii,ori_full_len,fp);
	fin.close();
	fclose(fp);

// delete junk
	string rm_command;
	rm_command = "";
	rm_command = rm_command + "rm -f error.log";
	retv=system(rm_command.c_str());

// move important file
	{
		string mvtmp_command;
		mvtmp_command = "mv " + tmpout + "/" +templateName+".pdb " + templateName+".pdb_post";
		retv=system(mvtmp_command.c_str());
	}

// keep temporary files or not
//	if(keeptmp==0)
	{
		string rmtmp_command;
		rmtmp_command = "rm -f " + tmpout + "/"  + templateName + "*";
		retv=system(rmtmp_command.c_str());
		rmtmp_command = "rmdir " + tmpout;
		retv=system(rmtmp_command.c_str());
	}

}


