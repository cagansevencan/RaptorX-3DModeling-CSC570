import os
import sys
import cPickle
import numpy as np

## this function converts MI matrix from half to full
def ExpandMatrix(input, seqLen):
        if not bool(input):
                return None

        v = input.values()[0]
        assert len(v) == 441

        out = np.zeros((seqLen, seqLen, 441), dtype=np.float16)
        for k, v in input.iteritems():
                i, j = k
                assert (i<j)
                if len(v) == 441:
                        out[i, j] = v
                        tmp = v.reshape(21, 21)
                        tmp2 = np.transpose(tmp)
                        out[j, i] = tmp2.flatten()

                else:
                        print 'ERROR: unsupported length for the value in a matrix dict()'
                        exit(1)

        return out

## infile is a cPickle file. It is a Python dict(), in which there are at least 3 keys: seqLen, PSFM, and MIM. 
## the MIM is in the half form
def LoadMatrix(infile):
	with open(infile, 'rb') as fh:
		content = cPickle.load(fh)
		seqLen = content['seqLen']
		MIM = ExpandMatrix(content['MIM'], seqLen)
		return MIM, content['PSFM']

## this function reads a cov matrix file generated by cov21stats_JX, convert it to half form and np.float16 and finally save it to a cPickle file
def main(argv):
	if len(argv) < 1:
		print 'Usage: one inputFile for original MI matrix is expected. The file shall be generated by CalcFullMI'
		exit(1)

	mifile = argv[0]

	## mifile shall be a binary file containing sequence length (int), seqlen * 21 float for position-specific frequency matrix plus seqlen*seqlen*21*21 float for full MI matrix
	fh = open(mifile, 'rb')
	seqLen = np.fromfile(fh, dtype=np.int32, count=1)[0]
	fh.seek(4)
	allvalues = np.fromfile(fh, dtype=np.float32)
	fh.close()

	assert seqLen > 0

	numValues = seqLen*21 + seqLen*seqLen*21*21
	if numValues != len(allvalues):
		print 'the file may be damaged: ', mifile
		print 'seqLen: ', seqLen, ' expected # values: ', numValues, ' available # values: ', len(allvalues)
		exit(1)

	PSFM = allvalues[: seqLen*21].reshape((seqLen, 21)).astype(np.float16)
	MIM = allvalues[seqLen*21:].reshape((seqLen, seqLen, 21*21))

	## amplify the cov matrix by 10 before converting it to float16, which may help save precision
	MIM = MIM.astype(np.float16)

	## keep only half of the MI matrix
	newMIM = dict()
	for i in range(seqLen):
		for j in range(i+1, seqLen):
			newMIM[(i, j)] = MIM[i, j]

	result=dict()
	result['seqLen']=seqLen
	result['PSFM'] = PSFM
	result['MIM'] = newMIM

	if len(argv) >= 2:
		savefile = argv[1]
	else:
		target = os.path.basename(mifile).split('.')[0]
		savefile = target + '.mi.pkl'

	with open(savefile, 'wb') as fh:
		cPickle.dump(result, fh, protocol=cPickle.HIGHEST_PROTOCOL)

if __name__ == '__main__':
	main(sys.argv[1:])
